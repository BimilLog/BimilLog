name: BimilLog Core (Backend) CI/CD

on:
  push:
    branches:
      - main
    paths:
      - 'BimilLog_core/**'
      - '.github/workflows/core-deploy.yml'

jobs:
  test:
    runs-on: ubuntu-latest

    services:
      mysql:
        image: mysql:8
        env:
          MYSQL_ROOT_PASSWORD: testpassword
          MYSQL_DATABASE: bimillogTest
        ports:
          - 3306:3306
        options: >-
          --health-cmd="mysqladmin ping -h localhost"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5

      redis:
        image: redis:8-alpine
        ports:
          - 6380:6379
        options: >-
          --health-cmd="redis-cli ping"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'

      - name: Cache Gradle packages
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-

      - name: Restore firebase-adminsdk json
        run: |
          mkdir -p BimilLog_core/src/main/resources/firebase
          echo "${{ secrets.FIREBASE_ADMIN_JSON }}" | base64 -d > BimilLog_core/src/main/resources/firebase/growfarm-6cd79-firebase-adminsdk-fbsvc-ad2bc92194.json

      - name: Grant execute permission for gradlew
        run: chmod +x BimilLog_core/gradlew

      - name: Run all tests
        working-directory: BimilLog_core
        env:
          LOCAL_MYSQL_PASSWORD: testpassword
          KAKAO_CLIENT_ID: test
          KAKAO_CLIENT_SECRET: test
          KAKAO_ADMIN_KEY: test
          NAVER_CLIENT_ID: test
          NAVER_CLIENT_SECRET: test
          GOOGLE_CLIENT_ID: test
          GOOGLE_CLIENT_SECRET: test
          JWT_SECRET: testsecret12345678901234567890123456789012
          MESSAGE_SECRET: testsecret1234567890123456789012
        run: ./gradlew test --no-daemon

  build-and-deploy:
    runs-on: ubuntu-latest
    needs: test
    env:
      DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
      DOCKERHUB_PASSWORD: ${{ secrets.DOCKERHUB_PASSWORD }}
      IMAGE_REPO: jaeikjeong/bimillog

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Set up Docker
        uses: docker/setup-buildx-action@v2

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Restore firebase-adminsdk json
        run: |
          mkdir -p BimilLog_core/src/main/resources/firebase
          echo "${{ secrets.FIREBASE_ADMIN_JSON }}" | base64 -d > BimilLog_core/src/main/resources/firebase/growfarm-6cd79-firebase-adminsdk-fbsvc-ad2bc92194.json

      - name: Log in to Docker Hub
        run: echo "${DOCKERHUB_PASSWORD}" | docker login -u "${DOCKERHUB_USERNAME}" --password-stdin

      - name: Build and push backend image
        run: |
          cd BimilLog_core
          docker build -f backend.Dockerfile -t bimillog-backend .
          docker tag bimillog-backend:latest $IMAGE_REPO:backend
          docker push $IMAGE_REPO:backend

      - name: Copy docker-compose.yml and prometheus config to EC2
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.BASTION_HOST }}
          username: ${{ secrets.BASTION_USER }}
          key: ${{ secrets.BASTION_SSH_KEY }}
          source: "BimilLog_core/docker-compose.yml,BimilLog_core/prometheus"
          target: "/tmp/"

      - name: Deploy infrastructure (Redis, Prometheus) via Bastion Host
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.BASTION_HOST }}
          username: ${{ secrets.BASTION_USER }}
          key: ${{ secrets.BASTION_SSH_KEY }}
          script: |
            scp -i ~/growfarm-backend-server-key.pem -o StrictHostKeyChecking=no /tmp/BimilLog_core/docker-compose.yml ${{ secrets.SERVER_USER }}@${{ secrets.BACKEND_SERVER_IP }}:/home/ubuntu/
            scp -r -i ~/growfarm-backend-server-key.pem -o StrictHostKeyChecking=no /tmp/BimilLog_core/prometheus ${{ secrets.SERVER_USER }}@${{ secrets.BACKEND_SERVER_IP }}:/home/ubuntu/

            ssh -i ~/growfarm-backend-server-key.pem -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.BACKEND_SERVER_IP }} << 'ENDSSH'
              export REDIS_PASSWORD="${{ secrets.REDIS_PASSWORD }}"
              echo "${{ secrets.DOCKERHUB_PASSWORD }}" | docker login -u "${{ secrets.DOCKERHUB_USERNAME }}" --password-stdin
              cd /home/ubuntu
              docker compose up -d redis redis-exporter prometheus node-exporter
            ENDSSH

      - name: Blue-Green Deploy Backend via Bastion Host
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.BASTION_HOST }}
          username: ${{ secrets.BASTION_USER }}
          key: ${{ secrets.BASTION_SSH_KEY }}
          script: |
            ssh -i ~/growfarm-backend-server-key.pem -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.BACKEND_SERVER_IP }} << 'ENDSSH'
              set -e

              # Configuration
              BLUE_PORT=8080
              GREEN_PORT=8081
              BLUE_CONTAINER="bimillog-backend-blue"
              GREEN_CONTAINER="bimillog-backend-green"
              IMAGE="jaeikjeong/bimillog:backend"
              HEALTH_CHECK_PATH="/actuator/health"
              MAX_HEALTH_RETRIES=30
              HEALTH_CHECK_INTERVAL=2

              # Environment variables for backend
              ENV_VARS="-e SPRING_PROFILES_ACTIVE=prod \
                -e PROD_MYSQL_URL=${{ secrets.PROD_MYSQL_URL }} \
                -e PROD_MYSQL_USERNAME=${{ secrets.PROD_MYSQL_USERNAME }} \
                -e PROD_MYSQL_PASSWORD=${{ secrets.PROD_MYSQL_PASSWORD }} \
                -e PROD_REDIS_HOST=${{ secrets.PROD_REDIS_HOST }} \
                -e PROD_REDIS_PORT=${{ secrets.PROD_REDIS_PORT }} \
                -e REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }} \
                -e KAKAO_CLIENT_ID=${{ secrets.KAKAO_CLIENT_ID }} \
                -e KAKAO_CLIENT_SECRET=${{ secrets.KAKAO_CLIENT_SECRET }} \
                -e KAKAO_ADMIN_KEY=${{ secrets.KAKAO_ADMIN_KEY }} \
                -e PROD_KAKAO_REDIRECT_URL=${{ secrets.PROD_KAKAO_REDIRECT_URL }} \
                -e NAVER_CLIENT_ID=${{ secrets.NAVER_CLIENT_ID }} \
                -e NAVER_CLIENT_SECRET=${{ secrets.NAVER_CLIENT_SECRET }} \
                -e PROD_NAVER_REDIRECT_URL=${{ secrets.PROD_NAVER_REDIRECT_URL }} \
                -e GOOGLE_CLIENT_SECRET=${{ secrets.GOOGLE_CLIENT_SECRET }} \
                -e GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }} \
                -e PROD_GOOGLE_REDIRECT_URL=${{ secrets.PROD_GOOGLE_REDIRECT_URL }} \
                -e JWT_SECRET=${{ secrets.JWT_SECRET }} \
                -e MESSAGE_SECRET=${{ secrets.MESSAGE_SECRET }} \
                -e PROD_SERVER_SSE_URL=${{ secrets.PROD_SERVER_SSE_URL }} \
                -e PROD_SERVER_PORT=${{ secrets.PROD_SERVER_PORT }} \
                -e PROD_FLYWAY_LOCATIONS=${{ secrets.PROD_FLYWAY_LOCATIONS }}"

              VOLUMES="-v /home/ubuntu/logs:/app/logs -v /home/ubuntu/scouter/agent.java:/app/scouter-agent"

              echo "${{ secrets.DOCKERHUB_PASSWORD }}" | docker login -u "${{ secrets.DOCKERHUB_USERNAME }}" --password-stdin
              docker pull $IMAGE

              # Determine current active container and ports
              if docker ps --format '{{.Names}}' | grep -q "^${BLUE_CONTAINER}$"; then
                CURRENT_CONTAINER=$BLUE_CONTAINER
                CURRENT_PORT=$BLUE_PORT
                NEW_CONTAINER=$GREEN_CONTAINER
                NEW_PORT=$GREEN_PORT
              elif docker ps --format '{{.Names}}' | grep -q "^${GREEN_CONTAINER}$"; then
                CURRENT_CONTAINER=$GREEN_CONTAINER
                CURRENT_PORT=$GREEN_PORT
                NEW_CONTAINER=$BLUE_CONTAINER
                NEW_PORT=$BLUE_PORT
              else
                echo "No backend container running. Starting blue container..."
                CURRENT_CONTAINER=""
                CURRENT_PORT=""
                NEW_CONTAINER=$BLUE_CONTAINER
                NEW_PORT=$BLUE_PORT
              fi

              echo "Current: $CURRENT_CONTAINER:$CURRENT_PORT"
              echo "New: $NEW_CONTAINER:$NEW_PORT"

              # Remove new container if exists (from previous failed deployment)
              docker rm -f $NEW_CONTAINER 2>/dev/null || true

              # Start new container
              echo "Starting new container: $NEW_CONTAINER on port $NEW_PORT"
              docker run -d \
                --name $NEW_CONTAINER \
                --network bimillog-network \
                -p ${NEW_PORT}:8080 \
                $ENV_VARS \
                $VOLUMES \
                --restart unless-stopped \
                $IMAGE

              # Wait for new container to be healthy
              echo "Waiting for new container health check..."
              for i in $(seq 1 $MAX_HEALTH_RETRIES); do
                if curl -sf http://localhost:${NEW_PORT}${HEALTH_CHECK_PATH} > /dev/null 2>&1; then
                  echo "Health check passed on attempt $i"
                  break
                fi
                if [ $i -eq $MAX_HEALTH_RETRIES ]; then
                  echo "Health check failed after $MAX_HEALTH_RETRIES attempts"
                  docker logs $NEW_CONTAINER --tail 50
                  docker rm -f $NEW_CONTAINER
                  exit 1
                fi
                echo "Health check attempt $i failed, retrying in ${HEALTH_CHECK_INTERVAL}s..."
                sleep $HEALTH_CHECK_INTERVAL
              done

              # Save new active port for ALB registration
              echo $NEW_PORT > /home/ubuntu/.active_backend_port
              echo $CURRENT_PORT > /home/ubuntu/.old_backend_port
              echo $NEW_CONTAINER > /home/ubuntu/.active_backend_container
              echo $CURRENT_CONTAINER > /home/ubuntu/.old_backend_container

              echo "New container is healthy: $NEW_CONTAINER on port $NEW_PORT"
            ENDSSH

      - name: Switch ALB Target Group
        run: |
          NEW_PORT=$(aws ssm send-command \
            --instance-ids ${{ secrets.BACKEND_INSTANCE_ID }} \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=["cat /home/ubuntu/.active_backend_port"]' \
            --output text --query "Command.CommandId" 2>/dev/null || echo "")

          # Fallback: use SSH via bastion to get the port
          NEW_PORT=$(ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            -i <(echo "${{ secrets.BASTION_SSH_KEY }}") \
            ${{ secrets.BASTION_USER }}@${{ secrets.BASTION_HOST }} \
            "ssh -o StrictHostKeyChecking=no -i ~/growfarm-backend-server-key.pem ${{ secrets.SERVER_USER }}@${{ secrets.BACKEND_SERVER_IP }} 'cat /home/ubuntu/.active_backend_port'")

          OLD_PORT=$(ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            -i <(echo "${{ secrets.BASTION_SSH_KEY }}") \
            ${{ secrets.BASTION_USER }}@${{ secrets.BASTION_HOST }} \
            "ssh -o StrictHostKeyChecking=no -i ~/growfarm-backend-server-key.pem ${{ secrets.SERVER_USER }}@${{ secrets.BACKEND_SERVER_IP }} 'cat /home/ubuntu/.old_backend_port 2>/dev/null || echo \"\"'")

          echo "New port: $NEW_PORT, Old port: $OLD_PORT"

          # Register new target
          echo "Registering new target: ${{ secrets.BACKEND_INSTANCE_ID }}:${NEW_PORT}"
          aws elbv2 register-targets \
            --target-group-arn ${{ secrets.BACKEND_TARGET_GROUP_ARN }} \
            --targets Id=${{ secrets.BACKEND_INSTANCE_ID }},Port=${NEW_PORT}

          # Wait for new target to be healthy
          echo "Waiting for new target to be healthy..."
          aws elbv2 wait target-in-service \
            --target-group-arn ${{ secrets.BACKEND_TARGET_GROUP_ARN }} \
            --targets Id=${{ secrets.BACKEND_INSTANCE_ID }},Port=${NEW_PORT}

          # Deregister old target if exists
          if [ -n "$OLD_PORT" ]; then
            echo "Deregistering old target: ${{ secrets.BACKEND_INSTANCE_ID }}:${OLD_PORT}"
            aws elbv2 deregister-targets \
              --target-group-arn ${{ secrets.BACKEND_TARGET_GROUP_ARN }} \
              --targets Id=${{ secrets.BACKEND_INSTANCE_ID }},Port=${OLD_PORT} || true
          fi

          echo "ALB target switch completed!"

      - name: Cleanup old container via Bastion Host
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.BASTION_HOST }}
          username: ${{ secrets.BASTION_USER }}
          key: ${{ secrets.BASTION_SSH_KEY }}
          script: |
            ssh -i ~/growfarm-backend-server-key.pem -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.BACKEND_SERVER_IP }} << 'ENDSSH'
              OLD_CONTAINER=$(cat /home/ubuntu/.old_backend_container 2>/dev/null || echo "")
              if [ -n "$OLD_CONTAINER" ]; then
                echo "Stopping old container: $OLD_CONTAINER"
                docker stop $OLD_CONTAINER 2>/dev/null || true
                docker rm $OLD_CONTAINER 2>/dev/null || true
              fi
              docker image prune -f
              echo "Cleanup completed!"
            ENDSSH
